class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        vector<vector<int>> adjList(graph.size());
        for (int i = 0; i < graph.size(); i++) {
            for (int j = 0; j < graph.size(); j++) {
                if (i != j && graph[i][j]) {
                    adjList[i].push_back(j);
                }
            }
        }
        vector<int> base(graph.size(), 0);
        for (int i = 0; i < initial.size(); i++) {
            base[initial[i]] = 1;
        }
        int minCount = INT_MAX;
        sort(initial.begin(), initial.end());
        int toRemove = initial[0];
        for (int i = 0; i < initial.size(); i++) {
            vector<int> infections = base;
            infections[initial[i]] = 0;
            queue<int> q;
            vector<int> visited(graph.size(), 0);
            for (int j = 0; j < initial.size(); j++) {
                if (j != i) q.push(initial[j]);
            }
            while (!q.empty()) {
                int temp = q.front();
                q.pop();
                for (int k = 0; k < adjList[temp].size(); k++) {
                    int neighbor = adjList[temp][k];
                    int badNode = initial[i];
                    if (neighbor != badNode && !visited[neighbor]) {
                        visited[neighbor] = 1;
                        infections[neighbor] = 1;
                        q.push(neighbor);
                    }
                }
            }
            int tempCount = accumulate(infections.begin(), infections.end(), 0);
            if (tempCount < minCount) {
                toRemove = initial[i];
                minCount = tempCount;
            }
        }
        return toRemove;
    }
};